---
title: ts summary
published: true
category: typescript
subtitle: A set of two-state buttons that can be toggled on or off
date: 2022-09-22
---

# 요약 정리

## 타입스크립트를 사용하는 이유

1. 컴파일 과정에서 에러를 검출함으로써 흔히 발생할 수 있는 실수를 방지하여 안정성을 높일 수 있다.
    
    1. 예를 들어 undefined인 객체의 프로퍼티에 접근하려고 하는 경우가 될 수 있다.
    2. 숫자와 문자열을 곱하려고 하는 경우
    
    많은 테스트를 거치더라도 실행되었을 때 완벽한 모든 상황을 만족시키기는 어렵다.
    
2. 미래의 자신과 동료 개발들에게 문서화를 제공할 수 있다.
    
3. 리팩토링을 쉽게 한다.
    
4. 간단한 테스트를 건너뜀으로써 생산성을 높일 수 있다.
    

## 타입 확인 시점

1. 타입스크립트 소스 → 타입스크립트 AST
2. 타입 검사기가 AST를 확인
3. 타입스크립트 AST → 자바스크립트 소스

## 타입 시스템

타입 검사기가 프로그램에 타입을 할당하는 데 사용하는 규칙 집합

보통 2가지로 분류할 수 있다.

1. 명시적으로 알려주는 타입 시스템
    
    어노테이션을 사용하는 방식, `value: type` 으로 선언하는 것
    
    타입스크립트는 알아서 추론하기 때문에 알아서 추론하도록 두는 것이 코드를 줄일 수 있는 방법이기 때문에 보통 어노테이션을 생략한다.
    
2. 자동으로 타입을 추론하는 타입 시스템
    

타입스크립트의 타입시스템은 표현력이 좋을 뿐만 아니라 쉽게 사용할 수 있고, 타입 제한과 관계 선언을 쉽고 간결하게 만들어주며, 타입을 명시하지 않아도 자동으로 추론해준다.

## JS vs TS

## 점진적 타입 언어

프로그램을 컴파일하는데 반드시 모든 타입을 알아야하는 것은 아니다. 기존 자바스크립트를 타입스크립트로 마이그레이션할 때 유용하다.

타입을 지정하지 않은 프로그램이라도 그중 일부 타입을 추론해서 오류를 검출할 수 있지만, 모든 타입을 알지 못하는 상황에서 오류가 노출될 수 있기 때문에 위험하다.

## 타입이란

단순히 데이터의 형태라고 생각했지만, 좀 더 깊게 생각해보면 **값과 이 값으로 할 수 있는 일의 집합**이라고 할 수 있다.

## typescript 타입 계층

<img src="/images/posts/typescript-summary/1.png" />

### any

### unknown

타입을 미리 알 수 없을 때 any 대신 unknown을 사용해야한다.

unknown은 타입을 검사해서 refine하기 전까지 사용할 수 없게 강제한다.

### 타입 리터럴

오직 하나의 값을 나타내는 타입을 말한다. 예를 들어서

```tsx
let a = true // boolean
let b: true = true // true
```

위에 b는 boolean이 가질 수 있는 값 중에서 true로 한정시킨다. 안전성을 추가로 확보해주는 기능이다.

### 객체

```tsx
let a: { b: number}; 
```

위와 같은 a 객체는 b가 없거나 b이외에 다른 값이 있다면 에러를 발생시킨다.

만약 프로퍼티가 추가되는 것을 알리고 싶다면

1. 옵셔널 프로퍼티를 추가한다.
2. [key: number]: type 을 사용한다.

### null, undefined, void, never

undefined 값의 타입은 undefined 뿐이고, null의 타입은 null 뿐이다.

undefined는 값이 할당되지 않았다는 의미

null은 빈 값이라는 의미

void는 값을 반환하지 않는다는 의미, return 문을 포함하지 않는 함수

never은 절대 값을 반환하지 않는다는 의미, 예외를 던지거나 영원히 실행되는 함수

## var, let ,const

var와 let을 사용하면 일반적인 타입을 추론하는 반면에, const를 사용하면 구체적인 타입을 추론하게 한다.

## 함수

call-signatures, 함수의 인자와 리턴값의 타입을 추론한다. 인자마다 새로운 타입을 정의하는 대신에, 타입 시스템이 잘 갖춰져 있다면 정의된 타입으로 인자의 타입을 정의하는 것이 유지보수에 편리하다고 생각한다.

### 제네릭

객체 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법을 말한다.

다형성을 가질 수 있도록 한다. 다형성이란 여러 타입을 받아들임으로써 여러 형태를 가지는 것을 의미한다.

### 가변성

상황에 따른 서브 타입의 관계를 말한다. 제네릭에서 인자간의 서브타입으로 설명할 수 있다.

- 불변: 정확히 정의된 타입만을 허용
- 공변: `A` 가 `B` 의 서브 타입일 경우, `B` 에 `A` 를 할당할 수 있다.
- 반변: `A` 가 `B` 의 서브 타입일 경우, 함수 인자 `B` 함수 타입에 함수 인자 `A` 인 함수를 할당할 수 없다.
- 양변: 모두 허용

### 종합성

type-checker가 상황에 따른 검사를 수행

### 할당성

구조적 서브 타이핑에 따라서 A 라는 타입을 B에 할당할 수 있는지 평가하는 규칙

### 타입 넓히기

let 이나 var로 선언했고 타입이 넓혀지지 않은 변수에 다시 값을 할당하면 타입스크립트는 새로운 값에 맞게 변수의 타입을 넓힌다.

한 객체의 타입을 다른 객체의 타입에 할당할 수 있는지 확인할 때도 타입을 넓힌다. 객체 타입과 그 멤버들은 공변 관계이다.

오탈자를 잡을 수 있는 이유는 초과 프로퍼티 확인 기능 때문이다. fresh 객체 리터럴 타입 T를 다른 타입 U에 할당하려고 할 때, T가 U에는 존재하지 않는 프로퍼티를 가지고 있다면 에러로 처리한다. fresh 객체 리터럴 타입이란 타입 스크립트가 객체 리터럴로부터 추론한 타입을 말한다. 객체 리터럴이 assertion을 사용하거나 변수로 할당되면 fresh 객체 리터럴은 일반 타입 객체 타입으로 넓혀지면서 fresh함은 사라진다.

```tsx
type Options = {
	baseURL: string;
	cacheSize?: Number; 
	tier?: 'prod' | 'dev';
}

class API {
	constructor(options: Options){}
}

new API({baseURL: "", badtier: ""})
//Argument of type '{ baseURL: string; badtier: string; }' is not assignable to parameter of type 'Options'.
```

위 코드에서 생성자 함수의 인자로 전달된 객체를 fresh 객체라고 한다.

fresh객체는 추론된 타입이며 변수에 할당되지 않았기 때문에 타입 assertion이 완료되지 않았다.

타입 assertion이 완료되지 않으면 초과 프로퍼티 확인을 시작한다.