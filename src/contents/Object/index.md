---
title: 자바스크립트 객체
date: 2022-05-12
published: true
category: js
subtitle: A set of two-state buttons that can be toggled on or off
---

## 객체란

> 다양한 타입의 값을 key와 value로써 하나의 단위로 구성한 자료구조

자바스크립트는 객체 기반의 언어이고, 원시형 값을 제외한 나머지 모든 것은 모두 객체이다.

자바스크립트에서 사용할 수 있는 모든 값들은 프로퍼티의 값으로 사용될 수 있다.

객체는 프로퍼티와 프로퍼티를 조작할 수 있는 메서드를 하나의 단위로 구조화할 수 있어서 유용하다.

자바스크립트는 프로토타입 객체지향 언어로 다양한 객체 생성 방법을 지원한다.

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- (ES6) Class

### 객체 리터럴

> 리터럴이란 사람이 이해할 수 있는 문자나 기호를 통해서 값을 생성하는 표기법을 말한다.

객체 리터럴은 중괄호안에 0개 이상의 프로퍼티를 정의해서 사용하는 것을 말한다.

객체 리터럴의 중괄호는 코드 블럭을 의미하지 않는다. 일반적으로 코드 블럭의 닫는 중괄호 뒤에는 세미콜론을 붙이지만 객체 리터럴은 값으로 평가되기 때문에 뒤에 세미콜론을 붙이지 않는다.

프로퍼티 네이밍 규칙: 빈 문자열을 포함하는 문자열 또는 심볼 값

프로퍼티는 동적으로 생성될 수 있다.

계산된 키값을 사용하기 위해서는 대괄호안에서 정의해야한다.

프로퍼티의 값으로 미리 정의된 식별자를 사용할 수 있고, 리터럴 문에서는 키값을 따로 명시해주지 않아도 식별자를 키값으로 사용할 수 있다.

메서드를 정의할 때 function을 생략해서 사용할 수 있다.

```tsx
const obj = {
	a: 1,
	sayHi: function () {},
}

---

const obj = {
	a: 1;
	sayHi(){
	}
}
```

축약해서 정의한 메서드는 프로퍼티에 할당한 메서드와 다르게 동작한다.

---

## ProtoType

**프로토타입이란 객체 원형을 의미하고 모든 객체는 원형으로부터 체이닝을 통해서 상속받아서 프로퍼티나 메서드를 사용할 수 있다.**

자바스크립트는 원시값을 제외한 모든 것들이 객체로 이루어져 있고, 프로토타입 기반의 객체지향 언어이다.

객체 지향이란 객체(다양한 타입의 값들을 key와 value로서 하나의 단위로 만든 자료구조)의 상태와 상태를 조작하는 메서드를 가지는 하나의 기능을 담당하는 부품들을 통해서 프로그램을 만들어 나가는 것을 말한다.

상속은 객체 지향 언어의 핵심으로 어떤 객체의 프로퍼티나 메서드를 상속받아 그대로 사용하는 것을 말한다. 만약 인스턴스를 생성할 때마다 같은 프로퍼티와 메서드를 만든다면 메모리 낭비이다. 자바스크립트는 프로토타입을 기반으로 상속을 구현해서 불필요한 중복을 제거한다.

모든 객체는 [[Prototype]]이라는 슬롯을 가지며 저장되는 값은 프로토타입의 참조다. 프로토타입은 객체의 생성 방식에 의해서 결정된다. 예를 들어서 객체 리터럴로 생성된 객체는 Object 객체의 프로토타입이고, 생성자 함수를 통해서 생성된 객체는 생성자 함수 prototype에 바인딩된다.

#### \_ _ prototype _ \_ vs .prototype

1. [[prototype]] 슬롯에는 직접적으로 접근할 수 없다.
2. \_ _ prototype _ \_를 통해서 프로토타입 객체에 간접적으로 접근할 수 있다.
3. \_ _ prototype _ \_ 은 Object.prototype.**prototyp**으로 Object.protype의 프로퍼티이다.
4. \_ _ prototype _ \_과 prototype은 사용하는 주체가 다르다.
5. prototype은 함수 객체만이 소유한다.

<br />

#### 빌트인 객체 Object, Number, String 모두 생성자 함수다.

<br />

```tsx
// 생성자 함수
function a() {}
a.prototype.name = 'kam';

const A = new a(); // A의 [[prototyp]]슬롯은 a의 a.protype을 가르킨다.
A.name; // [[protype]] 체이닝을 통해서 a.prototype에 name프로퍼티를 사용한다.
A.__prototype__; // 을 통해서 [[protype]]인 a.prototype에 간접적으로 접근할 수 있다.
```

객체 리터럴을 통해서 생성된 객체는 Object.prototype을 가르킨다. Object 생성자 함수에 null, undefined를 넣게 되면 추정연산을 통해서 Object.prototype을 가르키는 빈객체를 내보낸다.

#### 장점

1. 간단하다.

   클래스 기반의 상속에서는 class등의 부가적인 문법이 필요하고, class를 선언하고 class로부터 인스턴스를 만드는 과정을 거쳐야한다. 하지만 프로토타입 상속은 간단하게 객체를 만들고 객체간의 상속관계를 규정할 수 있다.

2. 불필요한 코드를 줄일 수 있다.
3. 동적타이핑

   객체와 객체까리 직접적으로 상속관계를 가지기 때문에 프로토 타입의 객체를 런타임시에 동적으로 수정하여 자식객체에서 사용이 가능하다. 런타임시에 유연한 프로그래밍이 가능하게 한다.

#### 단점

1. 런타임시에 객체를 수정할 수 있기 때문에 버그를 유발할 수 있다.
2. 프로토타입 객체에대한 meta-data를 제공하지 않는다.
3. 상위의 프로토타입을 변경했을 경우 생기는 side effect가 굉장히 커진다.

### 프로토타입과 클래스 기반의 상속의 차이점

클래스 기반 상속은 class라는 개념이 존재하고 이를 수반해서 interface, abstract class 등의 추가적인 개념 또한 존재하지만

프로토타입 기반 상속은 객체라는 개념만 존재하고 객체들간의 관계설정을 통해서 상속을 구현한다.

---

## built-in, wrapper object

자바스크립는 크게 3가지의 객체로 분류할 수 있다.

- 표준 빌트인 객체
- 호스트 객체
- 사용자 정의 객체

#### 표준 빌트인 객체

ECMAScript spec에 정의된 객체를 말하며 전역에 공통 기능으로 제공된다. 자바스크립트 실행 환경에 관계없이 사용할 수 있고, 전역 객체의 프로퍼티로서 제공된다.

Object, String, Number, Date, Array, Function 등으로 약 40개 정도의 표준 빌트인 객체가 있다.

대부분의 빌트인 객체는 인스턴스를 생성할 수 있는 생성자 함수 객체로 프로토타입 메서드와 정적 메서드를 제공한다.

```tsx
const strObj = new String('kam'); // String {"kam"}
const numObj = new Number(123); // Number {123}
```

빌트인 객체가 생성한 인스턴스의 프로토타입은 빌트인 객체의 프로토타입에 바인딩된다.

#### 호스트 객체

ECMAScript spec에 정의되어 있지 않지만 자바스크립트 환경에서 제공하는 객체를 말한다. 브라우저 환경에서 DOM, fetch, RequestAnimationFrame, WebStorage 등이 해당된다.

#### 사용자 정의 객체

사용자가 직접 정의한 객체를 말한다.

<br />

#### **primitive data인데 어떻게 내장 함수를 사용할 수 있는걸까?**

원시값인 문자열, 숫자 등과 같은 경우 객체처럼 `.` 을 통해서 접근하게 되면 자바스트립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해주기 때문이다.

원시값을 객체처럼 사용하면 자바스크립트 엔진이 암묵적으로 연관된 객체를 생성하여 생성된 객체로 프로퍼티에 접근하거나 메서드를 호출하고 다시 원시값으로 되돌린다.

이처럼 잠시 생성되는 임시 객체를 Wrapper Object라고 한다.

예를 들어서 string 원시값을 객체처럼 접근하게 되면

```tsx
const str = 'hello'; // 1
const str.name = 'kam'; // 2
											 //3
console.log(str.name); // 4
console.log(typeof str, str); // 5
```

1. str 변수는 ‘hello’ 문자열을 값으로 가진다.
2. 원시값인 문자열에 객체처럼 접근해서 ‘name’프로터티에 ‘kam’을 저장하려고한다.
   1. 이때 str 변수는 임시로 생성된 String 래퍼 객체를 가리킨다.
   2. ‘hello’는 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된다.
   3. 래퍼 객체의 ‘name’ 프로퍼티가 동적으로 추가된다.
   4. ‘name’프로퍼티에 ‘kam’이 저장된다.
3. 변수 str은 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값을 다시 가진다.

   래퍼 객체는 참조되지 않으므로 GC에 대상이된다.

4. str에 ‘name’프로퍼티에 접근하려고 한다.
   1. 이때 다시 새로운 String 래퍼객체를 임시로 생성한다.
   2. ‘hello’는 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된다.
   3. 새로운 래퍼객체에는 ‘name’ 프로퍼티가 없으므로 ‘undefined’가 로그가 적힌다.
5. 3번 반복
6. 로그에 `String hello` 가 적힌다.

모든 원시값이 해당하는 것은 아니고 number, string, boolean이 래퍼객체를 생성하고 null, undefined는 래퍼객체를 생성하지 않는다.

이렇게 사용하는 이유는 편리함 때문이라고 생각한다. 이처럼 래퍼객체로 인해서 원시값을 마치 객체처럼 사용해서 빌트인 객체의 프로토타입 메소드 또는 프로퍼티를 참조할 수 있기 때문에 new 연사자와 함께 생성자 함수를 호출해서 인스턴스를 생성할 필요가 없기 때문이다.
